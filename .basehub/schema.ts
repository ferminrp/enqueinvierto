// This file was generated by basehub. Do not edit directly. Read more: https://basehub.com/docs/api-reference/basehub-sdk

/* eslint-disable */
/* eslint-disable eslint-comments/no-restricted-disable */
/* tslint:disable */

// @ts-nocheck
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */

export type Scalars = {
    BSHBEventSchema: ({
  name: string;
  required: boolean;
  placeholder?: string;
  defaultValue?: string;
  helpText?: string
} & {
  id: string;
  label: string
} & ({
  type: "text" | "textarea" | "number" | "file" | "date" | "datetime" | "email" | "checkbox" | "hidden"
} | {
  type: "select" | "radio";
  options: string[];
  multiple: boolean
}))[],
    BSHBRichTextContentSchema: RichTextNode[],
    BSHBRichTextTOCSchema: RichTextTocNode[],
    Boolean: boolean,
    CodeSnippetLanguage: B_Language,
    DateTime: any,
    Float: number,
    ID: string,
    Int: number,
    JSON: any,
    String: string,
}

export type AnalyticsKeyScope = 'query' | 'send'

export interface BaseRichTextJson {
    blocks: Scalars['String']
    content: Scalars['BSHBRichTextContentSchema']
    toc: Scalars['BSHBRichTextTOCSchema']
    __typename: 'BaseRichTextJson'
}

export interface BlockAudio {
    /** The duration of the audio in seconds. If the duration is not available, it will be estimated based on the file size. */
    duration: Scalars['Float']
    fileName: Scalars['String']
    fileSize: Scalars['Int']
    lastModified: Scalars['Float']
    mimeType: Scalars['String']
    url: Scalars['String']
    __typename: 'BlockAudio'
}

export interface BlockCodeSnippet {
    allowedLanguages: Scalars['CodeSnippetLanguage'][]
    code: Scalars['String']
    /** @deprecated Figuring out the correct api. */
    html: Scalars['String']
    language: Scalars['CodeSnippetLanguage']
    __typename: 'BlockCodeSnippet'
}

export interface BlockColor {
    b: Scalars['Int']
    g: Scalars['Int']
    hex: Scalars['String']
    hsl: Scalars['String']
    r: Scalars['Int']
    rgb: Scalars['String']
    __typename: 'BlockColor'
}

export type BlockDocument = (Glosario | GlosarioItem | glosarioItem_AsList) & { __isUnion?: true }

export interface BlockDocumentSys {
    apiNamePath: Scalars['String']
    createdAt: Scalars['String']
    hash: Scalars['String']
    id: Scalars['ID']
    idPath: Scalars['String']
    lastModifiedAt: Scalars['String']
    slug: Scalars['String']
    slugPath: Scalars['String']
    title: Scalars['String']
    __typename: 'BlockDocumentSys'
}

export interface BlockFile {
    fileName: Scalars['String']
    fileSize: Scalars['Int']
    lastModified: Scalars['Float']
    mimeType: Scalars['String']
    url: Scalars['String']
    __typename: 'BlockFile'
}

export interface BlockImage {
    alt: (Scalars['String'] | null)
    aspectRatio: Scalars['String']
    blurDataURL: Scalars['String']
    fileName: Scalars['String']
    fileSize: Scalars['Int']
    height: Scalars['Int']
    lastModified: Scalars['Float']
    mimeType: Scalars['String']
    /** @deprecated Renamed to `blurDataURL` to match Next.js Image's naming convention. */
    placeholderURL: Scalars['String']
    /** @deprecated Use `url` instead. */
    rawUrl: Scalars['String']
    thumbhash: Scalars['String']
    /**
     * This field is used to generate the image URL with the provided options. The options are passed as arguments. For example, if you want to resize the image to 200x200 pixels, you can use the following query:
     * 
     * ```graphql
     * {
     *   imageBlock {
     *     url(width: 200, height: 200)
     *   }
     * }
     * ```
     * 
     * This will return the URL with the width and height set to 200 pixels.
     * 
     * BaseHub uses Cloudflare for image resizing. Check out [all available options in their docs](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#fetch-options).
     * 
     */
    url: Scalars['String']
    width: Scalars['Int']
    __typename: 'BlockImage'
}

export type BlockList = (Glosario | glosarioItem_AsList) & { __isUnion?: true }

export interface BlockOgImage {
    height: Scalars['Int']
    url: Scalars['String']
    width: Scalars['Int']
    __typename: 'BlockOgImage'
}


/** Rich text block */
export type BlockRichText = (Content) & { __isUnion?: true }

export interface BlockVideo {
    aspectRatio: Scalars['String']
    /** The duration of the video in seconds. If the duration is not available, it will be estimated based on the file size. */
    duration: Scalars['Float']
    fileName: Scalars['String']
    fileSize: Scalars['Int']
    height: Scalars['Int']
    lastModified: Scalars['Float']
    mimeType: Scalars['String']
    url: Scalars['String']
    width: Scalars['Int']
    __typename: 'BlockVideo'
}

export interface Content {
    html: Scalars['String']
    json: ContentRichText
    markdown: Scalars['String']
    plainText: Scalars['String']
    readingTime: Scalars['Int']
    __typename: 'Content'
}

export interface ContentRichText {
    content: Scalars['BSHBRichTextContentSchema']
    toc: Scalars['BSHBRichTextTOCSchema']
    __typename: 'ContentRichText'
}

export interface GetUploadSignedURL {
    signedURL: Scalars['String']
    uploadURL: Scalars['String']
    __typename: 'GetUploadSignedURL'
}

export interface Glosario {
    _analyticsKey: Scalars['String']
    _dashboardUrl: Scalars['String']
    _id: Scalars['String']
    _idPath: Scalars['String']
    _meta: ListMeta
    /** The key used to search from the frontend. */
    _searchKey: Scalars['String']
    _slug: Scalars['String']
    _slugPath: Scalars['String']
    _sys: BlockDocumentSys
    _title: Scalars['String']
    /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
    item: (GlosarioItem | null)
    /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
    items: GlosarioItem[]
    __typename: 'Glosario'
}

export interface GlosarioItem {
    _analyticsKey: Scalars['String']
    _dashboardUrl: Scalars['String']
    _id: Scalars['String']
    _idPath: Scalars['String']
    _slug: Scalars['String']
    _slugPath: Scalars['String']
    _sys: BlockDocumentSys
    _title: Scalars['String']
    content: (Content | null)
    /** ISO 8601 date string. */
    date: (Scalars['String'] | null)
    icon: (Scalars['String'] | null)
    slug: (Scalars['String'] | null)
    __typename: 'GlosarioItem'
}

export type GlosarioItemOrderByEnum = '_sys_createdAt__ASC' | '_sys_createdAt__DESC' | '_sys_hash__ASC' | '_sys_hash__DESC' | '_sys_id__ASC' | '_sys_id__DESC' | '_sys_lastModifiedAt__ASC' | '_sys_lastModifiedAt__DESC' | '_sys_slug__ASC' | '_sys_slug__DESC' | '_sys_title__ASC' | '_sys_title__DESC' | 'content__ASC' | 'content__DESC' | 'date__ASC' | 'date__DESC' | 'icon__ASC' | 'icon__DESC' | 'slug__ASC' | 'slug__DESC'

export interface ListMeta {
    /** Number of items after applying filters but before pagination */
    filteredCount: Scalars['Int']
    /** Total number of items in collection before any filtering/pagination */
    totalCount: Scalars['Int']
    __typename: 'ListMeta'
}

export type MediaBlock = (BlockAudio | BlockFile | BlockImage | BlockVideo) & { __isUnion?: true }

export type MediaBlockUnion = (BlockAudio | BlockFile | BlockImage | BlockVideo) & { __isUnion?: true }

export interface Mutation {
    /**
     * Returns a signed url and an upload url so that you can upload files into your repository.
     * 
     * Example usage with JavaScript:
     * ```js
     * async function handleUpload(file: File) {
     *   const { getUploadSignedURL } = await basehub().mutation({
     *     getUploadSignedURL: {
     *       __args: { fileName: file.name },
     *       signedURL: true,
     *       uploadURL: true,
     *     }
     *   })
     * 
     *   const { signedURL, uploadURL } = getUploadSignedURL
     * 
     *   await fetch(signedURL, { method: 'PUT', body: file })
     * 
     *   // done! do something with the uploadURL now
     * }
     * ```
     * 
     */
    getUploadSignedURL: GetUploadSignedURL
    /** Start a job that can be awaited and the result given directly. Under the hood, it runs `transactionAsync` and polls for the result until it is available. You can pass a `timeout` argument, the default being 30_000ms. */
    transaction: TransactionStatus
    /** Start an asynchronous job to mutate BaseHub data. Returns a transaction ID which you can use to get the result of the job. */
    transactionAsync: Scalars['String']
    transactionStatus: TransactionStatus
    __typename: 'Mutation'
}

export interface Query {
    /** Query across all of the instances of a component. Pass in filters and sorts if you want, and get each instance via the `items` key. */
    _componentInstances: _components
    /** The structure of the repository. Used by START. */
    _structure: Scalars['JSON']
    _sys: RepoSys
    glosario: Glosario
    __typename: 'Query'
}

export interface RepoSys {
    dashboardUrl: Scalars['String']
    forkUrl: Scalars['String']
    hash: Scalars['String']
    id: Scalars['ID']
    slug: Scalars['String']
    title: Scalars['String']
    __typename: 'RepoSys'
}

export type RichTextJson = (BaseRichTextJson | ContentRichText) & { __isUnion?: true }

export interface TransactionStatus {
    /** Duration in milliseconds. */
    duration: (Scalars['Int'] | null)
    endedAt: (Scalars['String'] | null)
    id: Scalars['String']
    message: (Scalars['String'] | null)
    startedAt: Scalars['String']
    status: TransactionStatusEnum
    __typename: 'TransactionStatus'
}

export type TransactionStatusEnum = 'Cancelled' | 'Completed' | 'Failed' | 'Running' | 'Scheduled'

export interface Variant {
    apiName: Scalars['String']
    color: Scalars['String']
    id: Scalars['String']
    isDefault: Scalars['Boolean']
    label: Scalars['String']
    __typename: 'Variant'
}

export type _ResolveTargetsWithEnum = 'id' | 'objectName'

export type _StructureFormatEnum = 'json' | 'xml'

export interface _components {
    glosarioItem: glosarioItem_AsList
    __typename: '_components'
}

export interface glosarioItem_AsList {
    _analyticsKey: Scalars['String']
    _dashboardUrl: Scalars['String']
    _id: Scalars['String']
    _idPath: Scalars['String']
    _meta: ListMeta
    /** The key used to search from the frontend. */
    _searchKey: Scalars['String']
    _slug: Scalars['String']
    _slugPath: Scalars['String']
    _sys: BlockDocumentSys
    _title: Scalars['String']
    /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
    item: (GlosarioItem | null)
    /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
    items: GlosarioItem[]
    __typename: 'glosarioItem_AsList'
}

export interface BaseRichTextJsonGenqlSelection{
    blocks?: boolean | number
    content?: boolean | number
    toc?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockAudioGenqlSelection{
    /** The duration of the audio in seconds. If the duration is not available, it will be estimated based on the file size. */
    duration?: boolean | number
    fileName?: boolean | number
    fileSize?: boolean | number
    lastModified?: boolean | number
    mimeType?: boolean | number
    url?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockCodeSnippetGenqlSelection{
    allowedLanguages?: boolean | number
    code?: boolean | number
    /** @deprecated Figuring out the correct api. */
    html?: { __args: {
    /** Theme for the code snippet */
    theme?: (Scalars['String'] | null)} } | boolean | number
    language?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockColorGenqlSelection{
    b?: boolean | number
    g?: boolean | number
    hex?: boolean | number
    hsl?: boolean | number
    r?: boolean | number
    rgb?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockDocumentGenqlSelection{
    _analyticsKey?: { __args: {
    /**
     * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
     * 
     * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
     */
    scope?: (AnalyticsKeyScope | null)} } | boolean | number
    _dashboardUrl?: boolean | number
    _id?: boolean | number
    _idPath?: boolean | number
    _slug?: boolean | number
    _slugPath?: boolean | number
    _sys?: BlockDocumentSysGenqlSelection
    _title?: boolean | number
    on_Glosario?: GlosarioGenqlSelection
    on_GlosarioItem?: GlosarioItemGenqlSelection
    on_glosarioItem_AsList?: glosarioItem_AsListGenqlSelection
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockDocumentSysGenqlSelection{
    apiNamePath?: boolean | number
    createdAt?: boolean | number
    hash?: boolean | number
    id?: boolean | number
    idPath?: boolean | number
    lastModifiedAt?: boolean | number
    slug?: boolean | number
    slugPath?: boolean | number
    title?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockFileGenqlSelection{
    fileName?: boolean | number
    fileSize?: boolean | number
    lastModified?: boolean | number
    mimeType?: boolean | number
    url?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockImageGenqlSelection{
    alt?: boolean | number
    aspectRatio?: boolean | number
    blurDataURL?: boolean | number
    fileName?: boolean | number
    fileSize?: boolean | number
    height?: boolean | number
    lastModified?: boolean | number
    mimeType?: boolean | number
    /** @deprecated Renamed to `blurDataURL` to match Next.js Image's naming convention. */
    placeholderURL?: boolean | number
    /** @deprecated Use `url` instead. */
    rawUrl?: boolean | number
    thumbhash?: boolean | number
    /**
     * This field is used to generate the image URL with the provided options. The options are passed as arguments. For example, if you want to resize the image to 200x200 pixels, you can use the following query:
     * 
     * ```graphql
     * {
     *   imageBlock {
     *     url(width: 200, height: 200)
     *   }
     * }
     * ```
     * 
     * This will return the URL with the width and height set to 200 pixels.
     * 
     * BaseHub uses Cloudflare for image resizing. Check out [all available options in their docs](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#fetch-options).
     * 
     */
    url?: { __args: {anim?: (Scalars['String'] | null), background?: (Scalars['String'] | null), blur?: (Scalars['Int'] | null), border?: (Scalars['String'] | null), brightness?: (Scalars['Int'] | null), compression?: (Scalars['String'] | null), contrast?: (Scalars['Int'] | null), dpr?: (Scalars['Int'] | null), fit?: (Scalars['String'] | null), format?: (Scalars['String'] | null), gamma?: (Scalars['String'] | null), gravity?: (Scalars['String'] | null), height?: (Scalars['Int'] | null), metadata?: (Scalars['String'] | null), quality?: (Scalars['Int'] | null), rotate?: (Scalars['String'] | null), sharpen?: (Scalars['String'] | null), trim?: (Scalars['String'] | null), width?: (Scalars['Int'] | null)} } | boolean | number
    width?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockListGenqlSelection{
    _analyticsKey?: { __args: {
    /**
     * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
     * 
     * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
     */
    scope?: (AnalyticsKeyScope | null)} } | boolean | number
    _dashboardUrl?: boolean | number
    _id?: boolean | number
    _idPath?: boolean | number
    _meta?: ListMetaGenqlSelection
    /** The key used to search from the frontend. */
    _searchKey?: boolean | number
    _slug?: boolean | number
    _slugPath?: boolean | number
    _sys?: BlockDocumentSysGenqlSelection
    _title?: boolean | number
    on_Glosario?: GlosarioGenqlSelection
    on_glosarioItem_AsList?: glosarioItem_AsListGenqlSelection
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockOgImageGenqlSelection{
    height?: boolean | number
    url?: boolean | number
    width?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}


/** Rich text block */
export interface BlockRichTextGenqlSelection{
    html?: { __args: {
    /** It automatically generates a unique id for each heading present in the HTML. Enabled by default. */
    slugs?: (Scalars['Boolean'] | null), 
    /** Inserts a table of contents at the beginning of the HTML. */
    toc?: (Scalars['Boolean'] | null)} } | boolean | number
    json?: RichTextJsonGenqlSelection
    markdown?: boolean | number
    plainText?: boolean | number
    readingTime?: { __args: {
    /** Words per minute, defaults to average 183wpm */
    wpm?: (Scalars['Int'] | null)} } | boolean | number
    on_Content?: ContentGenqlSelection
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface BlockVideoGenqlSelection{
    aspectRatio?: boolean | number
    /** The duration of the video in seconds. If the duration is not available, it will be estimated based on the file size. */
    duration?: boolean | number
    fileName?: boolean | number
    fileSize?: boolean | number
    height?: boolean | number
    lastModified?: boolean | number
    mimeType?: boolean | number
    url?: boolean | number
    width?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface ContentGenqlSelection{
    html?: { __args: {
    /** It automatically generates a unique id for each heading present in the HTML. Enabled by default. */
    slugs?: (Scalars['Boolean'] | null), 
    /** Inserts a table of contents at the beginning of the HTML. */
    toc?: (Scalars['Boolean'] | null)} } | boolean | number
    json?: ContentRichTextGenqlSelection
    markdown?: boolean | number
    plainText?: boolean | number
    readingTime?: { __args: {
    /** Words per minute, defaults to average 183wpm */
    wpm?: (Scalars['Int'] | null)} } | boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface ContentRichTextGenqlSelection{
    content?: boolean | number
    toc?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface DateFilter {eq?: (Scalars['DateTime'] | null),isAfter?: (Scalars['DateTime'] | null),isBefore?: (Scalars['DateTime'] | null),isNull?: (Scalars['Boolean'] | null),neq?: (Scalars['DateTime'] | null),onOrAfter?: (Scalars['DateTime'] | null),onOrBefore?: (Scalars['DateTime'] | null)}

export interface GetUploadSignedURLGenqlSelection{
    signedURL?: boolean | number
    uploadURL?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface GlosarioGenqlSelection{
    _analyticsKey?: { __args: {
    /**
     * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
     * 
     * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
     */
    scope?: (AnalyticsKeyScope | null)} } | boolean | number
    _dashboardUrl?: boolean | number
    _id?: boolean | number
    _idPath?: boolean | number
    _meta?: ListMetaGenqlSelection
    /** The key used to search from the frontend. */
    _searchKey?: boolean | number
    _slug?: boolean | number
    _slugPath?: boolean | number
    _sys?: BlockDocumentSysGenqlSelection
    _title?: boolean | number
    /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
    item?: GlosarioItemGenqlSelection
    /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
    items?: GlosarioItemGenqlSelection
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface GlosarioItemGenqlSelection{
    _analyticsKey?: { __args: {
    /**
     * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
     * 
     * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
     */
    scope?: (AnalyticsKeyScope | null)} } | boolean | number
    _dashboardUrl?: boolean | number
    _id?: boolean | number
    _idPath?: boolean | number
    _slug?: boolean | number
    _slugPath?: boolean | number
    _sys?: BlockDocumentSysGenqlSelection
    _title?: boolean | number
    content?: ContentGenqlSelection
    /** ISO 8601 date string. */
    date?: boolean | number
    icon?: boolean | number
    slug?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface GlosarioItemFilterInput {AND?: (GlosarioItemFilterInput | null),OR?: (GlosarioItemFilterInput | null),_id?: (StringFilter | null),_slug?: (StringFilter | null),_sys_apiNamePath?: (StringFilter | null),_sys_createdAt?: (DateFilter | null),_sys_hash?: (StringFilter | null),_sys_id?: (StringFilter | null),_sys_idPath?: (StringFilter | null),_sys_lastModifiedAt?: (DateFilter | null),_sys_slug?: (StringFilter | null),_sys_slugPath?: (StringFilter | null),_sys_title?: (StringFilter | null),_title?: (StringFilter | null),date?: (DateFilter | null),icon?: (StringFilter | null),slug?: (StringFilter | null)}

export interface ListFilter {isEmpty?: (Scalars['Boolean'] | null),length?: (Scalars['Int'] | null)}

export interface ListMetaGenqlSelection{
    /** Number of items after applying filters but before pagination */
    filteredCount?: boolean | number
    /** Total number of items in collection before any filtering/pagination */
    totalCount?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface MediaBlockGenqlSelection{
    fileName?: boolean | number
    fileSize?: boolean | number
    lastModified?: boolean | number
    mimeType?: boolean | number
    url?: boolean | number
    on_BlockAudio?: BlockAudioGenqlSelection
    on_BlockFile?: BlockFileGenqlSelection
    on_BlockImage?: BlockImageGenqlSelection
    on_BlockVideo?: BlockVideoGenqlSelection
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface MediaBlockUnionGenqlSelection{
    on_BlockAudio?:BlockAudioGenqlSelection,
    on_BlockFile?:BlockFileGenqlSelection,
    on_BlockImage?:BlockImageGenqlSelection,
    on_BlockVideo?:BlockVideoGenqlSelection,
    on_MediaBlock?: MediaBlockGenqlSelection,
    __typename?: boolean | number
}

export interface MutationGenqlSelection{
    /**
     * Returns a signed url and an upload url so that you can upload files into your repository.
     * 
     * Example usage with JavaScript:
     * ```js
     * async function handleUpload(file: File) {
     *   const { getUploadSignedURL } = await basehub().mutation({
     *     getUploadSignedURL: {
     *       __args: { fileName: file.name },
     *       signedURL: true,
     *       uploadURL: true,
     *     }
     *   })
     * 
     *   const { signedURL, uploadURL } = getUploadSignedURL
     * 
     *   await fetch(signedURL, { method: 'PUT', body: file })
     * 
     *   // done! do something with the uploadURL now
     * }
     * ```
     * 
     */
    getUploadSignedURL?: (GetUploadSignedURLGenqlSelection & { __args: {
    /** SHA256 hash of the file. Used for reusing existing files. */
    fileHash?: (Scalars['String'] | null), 
    /** The file name */
    fileName: Scalars['String']} })
    /** Start a job that can be awaited and the result given directly. Under the hood, it runs `transactionAsync` and polls for the result until it is available. You can pass a `timeout` argument, the default being 30_000ms. */
    transaction?: (TransactionStatusGenqlSelection & { __args: {
    /** Auto make a commit in your Repo with the specified message. */
    autoCommit?: (Scalars['String'] | null), 
    /** Transaction data. */
    data: Scalars['String'], 
    /** Skip running workflows and event subscribers. Defaults to false. */
    skipWorkflows?: (Scalars['Boolean'] | null), 
    /** Timeout in milliseconds. */
    timeout?: (Scalars['Int'] | null)} })
    /** Start an asynchronous job to mutate BaseHub data. Returns a transaction ID which you can use to get the result of the job. */
    transactionAsync?: { __args: {
    /** Auto make a commit in your Repo with the specified message. */
    autoCommit?: (Scalars['String'] | null), 
    /** Transaction data. */
    data: Scalars['String'], 
    /** Skip running workflows and event subscribers. Defaults to false. */
    skipWorkflows?: (Scalars['Boolean'] | null)} }
    transactionStatus?: (TransactionStatusGenqlSelection & { __args: {
    /** Transaction ID */
    id: Scalars['String']} })
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface NumberFilter {eq?: (Scalars['Float'] | null),gt?: (Scalars['Float'] | null),gte?: (Scalars['Float'] | null),isNull?: (Scalars['Boolean'] | null),lt?: (Scalars['Float'] | null),lte?: (Scalars['Float'] | null),neq?: (Scalars['Float'] | null)}

export interface QueryGenqlSelection{
    /** Query across all of the instances of a component. Pass in filters and sorts if you want, and get each instance via the `items` key. */
    _componentInstances?: _componentsGenqlSelection
    /** The structure of the repository. Used by START. */
    _structure?: { __args: {
    /** The format of the structure. */
    format?: (_StructureFormatEnum | null), 
    /** The format of the structure. */
    resolveTargetsWith?: (_ResolveTargetsWithEnum | null), 
    /** A target block to forcefully resolve in the schema. */
    targetBlock?: (TargetBlock | null), 
    /** Whether to include constraints in the structure. */
    withConstraints?: (Scalars['Boolean'] | null), 
    /** Whether to include IDs in the structure. */
    withIDs?: (Scalars['Boolean'] | null), 
    /** Whether to include type options in the structure. */
    withTypeOptions?: (Scalars['Boolean'] | null)} } | boolean | number
    _sys?: RepoSysGenqlSelection
    glosario?: (GlosarioGenqlSelection & { __args?: {
    /** Filter by a field. */
    filter?: (GlosarioItemFilterInput | null), 
    /** Limit the number of items returned. Defaults to 500. */
    first?: (Scalars['Int'] | null), 
    /** Order by a field. */
    orderBy?: (GlosarioItemOrderByEnum | null), 
    /** Skip the first n items. */
    skip?: (Scalars['Int'] | null)} })
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface RepoSysGenqlSelection{
    dashboardUrl?: boolean | number
    forkUrl?: boolean | number
    hash?: boolean | number
    id?: boolean | number
    slug?: boolean | number
    title?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface RichTextJsonGenqlSelection{
    content?: boolean | number
    toc?: boolean | number
    on_BaseRichTextJson?: BaseRichTextJsonGenqlSelection
    on_ContentRichText?: ContentRichTextGenqlSelection
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface SelectFilter {excludes?: (Scalars['String'] | null),excludesAll?: (Scalars['String'][] | null),includes?: (Scalars['String'] | null),includesAll?: (Scalars['String'][] | null),includesAny?: (Scalars['String'][] | null),isEmpty?: (Scalars['Boolean'] | null)}

export interface StringFilter {contains?: (Scalars['String'] | null),endsWith?: (Scalars['String'] | null),eq?: (Scalars['String'] | null),isNull?: (Scalars['Boolean'] | null),matches?: (StringMatchesFilter | null),notEq?: (Scalars['String'] | null),startsWith?: (Scalars['String'] | null)}

export interface StringMatchesFilter {caseSensitive?: (Scalars['Boolean'] | null),pattern: Scalars['String']}

export interface TargetBlock {focus?: (Scalars['Boolean'] | null),id: Scalars['String'],label: Scalars['String']}

export interface TransactionStatusGenqlSelection{
    /** Duration in milliseconds. */
    duration?: boolean | number
    endedAt?: boolean | number
    id?: boolean | number
    message?: boolean | number
    startedAt?: boolean | number
    status?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface VariantGenqlSelection{
    apiName?: boolean | number
    color?: boolean | number
    id?: boolean | number
    isDefault?: boolean | number
    label?: boolean | number
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface _componentsGenqlSelection{
    glosarioItem?: (glosarioItem_AsListGenqlSelection & { __args?: {
    /** Filter by a field. */
    filter?: (GlosarioItemFilterInput | null), 
    /** Limit the number of items returned. Defaults to 500. */
    first?: (Scalars['Int'] | null), 
    /** Order by a field. */
    orderBy?: (GlosarioItemOrderByEnum | null), 
    /** Skip the first n items. */
    skip?: (Scalars['Int'] | null)} })
    __typename?: boolean | number
    __scalar?: boolean | number
}

export interface glosarioItem_AsListGenqlSelection{
    _analyticsKey?: { __args: {
    /**
     * The scope of the analytics key. Use `send` for just ingesting data. Use `query` if you need to show an analytics data in your website.
     * 
     * Have in mind, if you expose your `query` analytics key in the frontend, you'll be exposing all of this block's analytics data to the public. This is generally safe, but it might not be in your case.
     */
    scope?: (AnalyticsKeyScope | null)} } | boolean | number
    _dashboardUrl?: boolean | number
    _id?: boolean | number
    _idPath?: boolean | number
    _meta?: ListMetaGenqlSelection
    /** The key used to search from the frontend. */
    _searchKey?: boolean | number
    _slug?: boolean | number
    _slugPath?: boolean | number
    _sys?: BlockDocumentSysGenqlSelection
    _title?: boolean | number
    /** Returns the first item in the list, or null if the list is empty. Useful when you expect only one result. */
    item?: GlosarioItemGenqlSelection
    /** Returns the list of items after filtering and paginating according to the arguments sent by the client. */
    items?: GlosarioItemGenqlSelection
    __typename?: boolean | number
    __scalar?: boolean | number
}

type FragmentsMap = {
  BaseRichTextJson: {
    root: BaseRichTextJson,
    selection: BaseRichTextJsonGenqlSelection,
}
  BlockAudio: {
    root: BlockAudio,
    selection: BlockAudioGenqlSelection,
}
  BlockCodeSnippet: {
    root: BlockCodeSnippet,
    selection: BlockCodeSnippetGenqlSelection,
}
  BlockColor: {
    root: BlockColor,
    selection: BlockColorGenqlSelection,
}
  BlockDocument: {
    root: BlockDocument,
    selection: BlockDocumentGenqlSelection,
}
  BlockDocumentSys: {
    root: BlockDocumentSys,
    selection: BlockDocumentSysGenqlSelection,
}
  BlockFile: {
    root: BlockFile,
    selection: BlockFileGenqlSelection,
}
  BlockImage: {
    root: BlockImage,
    selection: BlockImageGenqlSelection,
}
  BlockList: {
    root: BlockList,
    selection: BlockListGenqlSelection,
}
  BlockOgImage: {
    root: BlockOgImage,
    selection: BlockOgImageGenqlSelection,
}
  BlockRichText: {
    root: BlockRichText,
    selection: BlockRichTextGenqlSelection,
}
  BlockVideo: {
    root: BlockVideo,
    selection: BlockVideoGenqlSelection,
}
  Content: {
    root: Content,
    selection: ContentGenqlSelection,
}
  ContentRichText: {
    root: ContentRichText,
    selection: ContentRichTextGenqlSelection,
}
  GetUploadSignedURL: {
    root: GetUploadSignedURL,
    selection: GetUploadSignedURLGenqlSelection,
}
  Glosario: {
    root: Glosario,
    selection: GlosarioGenqlSelection,
}
  GlosarioItem: {
    root: GlosarioItem,
    selection: GlosarioItemGenqlSelection,
}
  ListMeta: {
    root: ListMeta,
    selection: ListMetaGenqlSelection,
}
  MediaBlock: {
    root: MediaBlock,
    selection: MediaBlockGenqlSelection,
}
  Mutation: {
    root: Mutation,
    selection: MutationGenqlSelection,
}
  Query: {
    root: Query,
    selection: QueryGenqlSelection,
}
  RepoSys: {
    root: RepoSys,
    selection: RepoSysGenqlSelection,
}
  RichTextJson: {
    root: RichTextJson,
    selection: RichTextJsonGenqlSelection,
}
  TransactionStatus: {
    root: TransactionStatus,
    selection: TransactionStatusGenqlSelection,
}
  Variant: {
    root: Variant,
    selection: VariantGenqlSelection,
}
  _components: {
    root: _components,
    selection: _componentsGenqlSelection,
}
  glosarioItem_AsList: {
    root: glosarioItem_AsList,
    selection: glosarioItem_AsListGenqlSelection,
}
}

import { FieldsSelection } from "./runtime";

export function fragmentOn<
    TypeName extends keyof FragmentsMap,
    Selection extends FragmentsMap[TypeName]["selection"],
>(name: TypeName, fields: Selection) {
  return { __fragmentOn: name, ...fields } as const;
}

// credits: https://stackoverflow.com/a/54487392
type OmitDistributive<T, K extends PropertyKey> = T extends any
    ? T extends object
        ? Id<OmitRecursively<T, K>>
        : T
    : never
type Id<T> = {} & { [P in keyof T]: T[P] } // Cosmetic use only makes the tooltips expad the type can be removed
type OmitRecursively<T, K extends PropertyKey> = Omit<
    { [P in keyof T]: OmitDistributive<T[P], K> },
    K
>

export namespace fragmentOn {
    export type infer<T> = T extends {
      __fragmentOn: infer U extends keyof FragmentsMap;
    }
      ? OmitRecursively<FieldsSelection<FragmentsMap[U]["root"], Omit<T, "__fragmentOn">>, "__fragmentOn">
      : never;
  }


// This is a BaseHub-specific thing:

type RecursiveCollection<T, Key extends keyof T> = T & {
[key in Key]: { items: RecursiveCollection<T, Key> };
};

export function fragmentOnRecursiveCollection<
  TypeName extends keyof FragmentsMap,
  Selection extends FragmentsMap[TypeName]["selection"],
  RecursiveKey extends keyof FragmentsMap[TypeName]["selection"]
>(
  name: TypeName,
  fields: Selection,
  options: {
    recursiveKey: RecursiveKey;
    levels: number;
    getLevelArgs?: (level: number) => unknown;
  }
) {
  let current = {
    ...fields,
  } as RecursiveCollection<
    { readonly __fragmentOn: TypeName } & Selection,
    RecursiveKey
  >;
  if (options.levels > 0) {
    current[options.recursiveKey] = {
      ...(options.getLevelArgs
        ? { __args: options.getLevelArgs(options.levels) }
        : {}),
      items: fragmentOnRecursiveCollection(name, fields, {
        ...options,
        levels: options.levels - 1,
      }),
    } as any;
  }
  return current;
}




    const BaseRichTextJson_possibleTypes: string[] = ['BaseRichTextJson']
    export const isBaseRichTextJson = (obj?: { __typename?: any } | null): obj is BaseRichTextJson => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBaseRichTextJson"')
      return BaseRichTextJson_possibleTypes.includes(obj.__typename)
    }
    


    const BlockAudio_possibleTypes: string[] = ['BlockAudio']
    export const isBlockAudio = (obj?: { __typename?: any } | null): obj is BlockAudio => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockAudio"')
      return BlockAudio_possibleTypes.includes(obj.__typename)
    }
    


    const BlockCodeSnippet_possibleTypes: string[] = ['BlockCodeSnippet']
    export const isBlockCodeSnippet = (obj?: { __typename?: any } | null): obj is BlockCodeSnippet => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockCodeSnippet"')
      return BlockCodeSnippet_possibleTypes.includes(obj.__typename)
    }
    


    const BlockColor_possibleTypes: string[] = ['BlockColor']
    export const isBlockColor = (obj?: { __typename?: any } | null): obj is BlockColor => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockColor"')
      return BlockColor_possibleTypes.includes(obj.__typename)
    }
    


    const BlockDocument_possibleTypes: string[] = ['Glosario','GlosarioItem','glosarioItem_AsList']
    export const isBlockDocument = (obj?: { __typename?: any } | null): obj is BlockDocument => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockDocument"')
      return BlockDocument_possibleTypes.includes(obj.__typename)
    }
    


    const BlockDocumentSys_possibleTypes: string[] = ['BlockDocumentSys']
    export const isBlockDocumentSys = (obj?: { __typename?: any } | null): obj is BlockDocumentSys => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockDocumentSys"')
      return BlockDocumentSys_possibleTypes.includes(obj.__typename)
    }
    


    const BlockFile_possibleTypes: string[] = ['BlockFile']
    export const isBlockFile = (obj?: { __typename?: any } | null): obj is BlockFile => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockFile"')
      return BlockFile_possibleTypes.includes(obj.__typename)
    }
    


    const BlockImage_possibleTypes: string[] = ['BlockImage']
    export const isBlockImage = (obj?: { __typename?: any } | null): obj is BlockImage => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockImage"')
      return BlockImage_possibleTypes.includes(obj.__typename)
    }
    


    const BlockList_possibleTypes: string[] = ['Glosario','glosarioItem_AsList']
    export const isBlockList = (obj?: { __typename?: any } | null): obj is BlockList => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockList"')
      return BlockList_possibleTypes.includes(obj.__typename)
    }
    


    const BlockOgImage_possibleTypes: string[] = ['BlockOgImage']
    export const isBlockOgImage = (obj?: { __typename?: any } | null): obj is BlockOgImage => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockOgImage"')
      return BlockOgImage_possibleTypes.includes(obj.__typename)
    }
    


    const BlockRichText_possibleTypes: string[] = ['Content']
    export const isBlockRichText = (obj?: { __typename?: any } | null): obj is BlockRichText => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockRichText"')
      return BlockRichText_possibleTypes.includes(obj.__typename)
    }
    


    const BlockVideo_possibleTypes: string[] = ['BlockVideo']
    export const isBlockVideo = (obj?: { __typename?: any } | null): obj is BlockVideo => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isBlockVideo"')
      return BlockVideo_possibleTypes.includes(obj.__typename)
    }
    


    const Content_possibleTypes: string[] = ['Content']
    export const isContent = (obj?: { __typename?: any } | null): obj is Content => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isContent"')
      return Content_possibleTypes.includes(obj.__typename)
    }
    


    const ContentRichText_possibleTypes: string[] = ['ContentRichText']
    export const isContentRichText = (obj?: { __typename?: any } | null): obj is ContentRichText => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isContentRichText"')
      return ContentRichText_possibleTypes.includes(obj.__typename)
    }
    


    const GetUploadSignedURL_possibleTypes: string[] = ['GetUploadSignedURL']
    export const isGetUploadSignedURL = (obj?: { __typename?: any } | null): obj is GetUploadSignedURL => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isGetUploadSignedURL"')
      return GetUploadSignedURL_possibleTypes.includes(obj.__typename)
    }
    


    const Glosario_possibleTypes: string[] = ['Glosario']
    export const isGlosario = (obj?: { __typename?: any } | null): obj is Glosario => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isGlosario"')
      return Glosario_possibleTypes.includes(obj.__typename)
    }
    


    const GlosarioItem_possibleTypes: string[] = ['GlosarioItem']
    export const isGlosarioItem = (obj?: { __typename?: any } | null): obj is GlosarioItem => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isGlosarioItem"')
      return GlosarioItem_possibleTypes.includes(obj.__typename)
    }
    


    const ListMeta_possibleTypes: string[] = ['ListMeta']
    export const isListMeta = (obj?: { __typename?: any } | null): obj is ListMeta => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isListMeta"')
      return ListMeta_possibleTypes.includes(obj.__typename)
    }
    


    const MediaBlock_possibleTypes: string[] = ['BlockAudio','BlockFile','BlockImage','BlockVideo']
    export const isMediaBlock = (obj?: { __typename?: any } | null): obj is MediaBlock => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isMediaBlock"')
      return MediaBlock_possibleTypes.includes(obj.__typename)
    }
    


    const MediaBlockUnion_possibleTypes: string[] = ['BlockAudio','BlockFile','BlockImage','BlockVideo']
    export const isMediaBlockUnion = (obj?: { __typename?: any } | null): obj is MediaBlockUnion => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isMediaBlockUnion"')
      return MediaBlockUnion_possibleTypes.includes(obj.__typename)
    }
    


    const Mutation_possibleTypes: string[] = ['Mutation']
    export const isMutation = (obj?: { __typename?: any } | null): obj is Mutation => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isMutation"')
      return Mutation_possibleTypes.includes(obj.__typename)
    }
    


    const Query_possibleTypes: string[] = ['Query']
    export const isQuery = (obj?: { __typename?: any } | null): obj is Query => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isQuery"')
      return Query_possibleTypes.includes(obj.__typename)
    }
    


    const RepoSys_possibleTypes: string[] = ['RepoSys']
    export const isRepoSys = (obj?: { __typename?: any } | null): obj is RepoSys => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isRepoSys"')
      return RepoSys_possibleTypes.includes(obj.__typename)
    }
    


    const RichTextJson_possibleTypes: string[] = ['BaseRichTextJson','ContentRichText']
    export const isRichTextJson = (obj?: { __typename?: any } | null): obj is RichTextJson => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isRichTextJson"')
      return RichTextJson_possibleTypes.includes(obj.__typename)
    }
    


    const TransactionStatus_possibleTypes: string[] = ['TransactionStatus']
    export const isTransactionStatus = (obj?: { __typename?: any } | null): obj is TransactionStatus => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isTransactionStatus"')
      return TransactionStatus_possibleTypes.includes(obj.__typename)
    }
    


    const Variant_possibleTypes: string[] = ['Variant']
    export const isVariant = (obj?: { __typename?: any } | null): obj is Variant => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isVariant"')
      return Variant_possibleTypes.includes(obj.__typename)
    }
    


    const _components_possibleTypes: string[] = ['_components']
    export const is_components = (obj?: { __typename?: any } | null): obj is _components => {
      if (!obj?.__typename) throw new Error('__typename is missing in "is_components"')
      return _components_possibleTypes.includes(obj.__typename)
    }
    


    const glosarioItem_AsList_possibleTypes: string[] = ['glosarioItem_AsList']
    export const isglosarioItem_AsList = (obj?: { __typename?: any } | null): obj is glosarioItem_AsList => {
      if (!obj?.__typename) throw new Error('__typename is missing in "isglosarioItem_AsList"')
      return glosarioItem_AsList_possibleTypes.includes(obj.__typename)
    }
    

export const enumAnalyticsKeyScope = {
   query: 'query' as const,
   send: 'send' as const
}

export const enumGlosarioItemOrderByEnum = {
   _sys_createdAt__ASC: '_sys_createdAt__ASC' as const,
   _sys_createdAt__DESC: '_sys_createdAt__DESC' as const,
   _sys_hash__ASC: '_sys_hash__ASC' as const,
   _sys_hash__DESC: '_sys_hash__DESC' as const,
   _sys_id__ASC: '_sys_id__ASC' as const,
   _sys_id__DESC: '_sys_id__DESC' as const,
   _sys_lastModifiedAt__ASC: '_sys_lastModifiedAt__ASC' as const,
   _sys_lastModifiedAt__DESC: '_sys_lastModifiedAt__DESC' as const,
   _sys_slug__ASC: '_sys_slug__ASC' as const,
   _sys_slug__DESC: '_sys_slug__DESC' as const,
   _sys_title__ASC: '_sys_title__ASC' as const,
   _sys_title__DESC: '_sys_title__DESC' as const,
   content__ASC: 'content__ASC' as const,
   content__DESC: 'content__DESC' as const,
   date__ASC: 'date__ASC' as const,
   date__DESC: 'date__DESC' as const,
   icon__ASC: 'icon__ASC' as const,
   icon__DESC: 'icon__DESC' as const,
   slug__ASC: 'slug__ASC' as const,
   slug__DESC: 'slug__DESC' as const
}

export const enumTransactionStatusEnum = {
   Cancelled: 'Cancelled' as const,
   Completed: 'Completed' as const,
   Failed: 'Failed' as const,
   Running: 'Running' as const,
   Scheduled: 'Scheduled' as const
}

export const enum_resolveTargetsWithEnum = {
   id: 'id' as const,
   objectName: 'objectName' as const
}

export const enum_structureFormatEnum = {
   json: 'json' as const,
   xml: 'xml' as const
}

import type { RichTextNode, RichTextTocNode } from './api-transaction';
import type { Language as B_Language } from './react-code-block';

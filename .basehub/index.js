// This file was generated by basehub. Do not edit directly. Read more: https://basehub.com/docs/api-reference/basehub-sdk

/* eslint-disable */
/* eslint-disable eslint-comments/no-restricted-disable */
/* tslint:disable */

// .basehub/runtime/_error.ts
var GenqlError = class extends Error {
  constructor(errors, data) {
    let message = Array.isArray(errors) ? errors.map((x) => x?.message || "").join("\n") : "";
    if (!message) {
      message = "GraphQL error";
    }
    super(message);
    this.errors = [];
    this.errors = errors;
    this.data = data;
  }
};

// .basehub/runtime/_batcher.ts
function dispatchQueueBatch(client, queue) {
  let batchedQuery = queue.map((item) => item.request);
  if (batchedQuery.length === 1) {
    batchedQuery = batchedQuery[0];
  }
  ;
  (() => {
    try {
      return client.fetcher(batchedQuery);
    } catch (e) {
      return Promise.reject(e);
    }
  })().then((responses) => {
    if (queue.length === 1 && !Array.isArray(responses)) {
      if (responses.errors && responses.errors.length) {
        queue[0].reject(
          new GenqlError(responses.errors, responses.data)
        );
        return;
      }
      queue[0].resolve(responses);
      return;
    } else if (responses.length !== queue.length) {
      throw new Error("response length did not match query length");
    }
    for (let i = 0; i < queue.length; i++) {
      if (responses[i].errors && responses[i].errors.length) {
        queue[i].reject(
          new GenqlError(responses[i].errors, responses[i].data)
        );
      } else {
        queue[i].resolve(responses[i]);
      }
    }
  }).catch((e) => {
    for (let i = 0; i < queue.length; i++) {
      queue[i].reject(e);
    }
  });
}
function dispatchQueue(client, options) {
  const queue = client._queue;
  const maxBatchSize = options.maxBatchSize || 0;
  client._queue = [];
  if (maxBatchSize > 0 && maxBatchSize < queue.length) {
    for (let i = 0; i < queue.length / maxBatchSize; i++) {
      dispatchQueueBatch(
        client,
        queue.slice(i * maxBatchSize, (i + 1) * maxBatchSize)
      );
    }
  } else {
    dispatchQueueBatch(client, queue);
  }
}
var QueryBatcher = class _QueryBatcher {
  constructor(fetcher, {
    batchInterval = 16,
    shouldBatch = true,
    maxBatchSize = 0
  } = {}) {
    this.fetcher = fetcher;
    this._options = {
      batchInterval,
      shouldBatch,
      maxBatchSize
    };
    this._queue = [];
  }
  /**
   * Fetch will send a graphql request and return the parsed json.
   * @param {string}      query          - the graphql query.
   * @param {Variables}   variables      - any variables you wish to inject as key/value pairs.
   * @param {[string]}    operationName  - the graphql operationName.
   * @param {Options}     overrides      - the client options overrides.
   *
   * @return {promise} resolves to parsed json of server response
   *
   * @example
   * client.fetch(`
   *    query getHuman($id: ID!) {
   *      human(id: $id) {
   *        name
   *        height
   *      }
   *    }
   * `, { id: "1001" }, 'getHuman')
   *    .then(human => {
   *      // do something with human
   *      console.log(human);
   *    });
   */
  fetch(query, variables, operationName, overrides = {}) {
    const request = {
      query
    };
    const options = Object.assign({}, this._options, overrides);
    if (variables) {
      request.variables = variables;
    }
    if (operationName) {
      request.operationName = operationName;
    }
    const promise = new Promise((resolve, reject) => {
      this._queue.push({
        request,
        resolve,
        reject
      });
      if (this._queue.length === 1) {
        if (options.shouldBatch) {
          setTimeout(
            () => dispatchQueue(this, options),
            options.batchInterval
          );
        } else {
          dispatchQueue(this, options);
        }
      }
    });
    return promise;
  }
  /**
   * Fetch will send a graphql request and return the parsed json.
   * @param {string}      query          - the graphql query.
   * @param {Variables}   variables      - any variables you wish to inject as key/value pairs.
   * @param {[string]}    operationName  - the graphql operationName.
   * @param {Options}     overrides      - the client options overrides.
   *
   * @return {Promise<Array<Result>>} resolves to parsed json of server response
   *
   * @example
   * client.forceFetch(`
   *    query getHuman($id: ID!) {
   *      human(id: $id) {
   *        name
   *        height
   *      }
   *    }
   * `, { id: "1001" }, 'getHuman')
   *    .then(human => {
   *      // do something with human
   *      console.log(human);
   *    });
   */
  forceFetch(query, variables, operationName, overrides = {}) {
    const request = {
      query
    };
    const options = Object.assign({}, this._options, overrides, {
      shouldBatch: false
    });
    if (variables) {
      request.variables = variables;
    }
    if (operationName) {
      request.operationName = operationName;
    }
    const promise = new Promise((resolve, reject) => {
      const client = new _QueryBatcher(this.fetcher, this._options);
      client._queue = [
        {
          request,
          resolve,
          reject
        }
      ];
      dispatchQueue(client, options);
    });
    return promise;
  }
};

// .basehub/runtime/_fetcher.ts
var DEFAULT_BATCH_OPTIONS = {
  maxBatchSize: 10,
  batchInterval: 40
};
var createFetcher = ({
  url,
  headers = {},
  fetcher,
  fetch: _fetch,
  batch = false,
  ...rest
}) => {
  if (!url && !fetcher) {
    throw new Error("url or fetcher is required");
  }
  fetcher = fetcher || (async (body, extraFetchOptions) => {
    let headersObject = typeof headers == "function" ? await headers() : headers;
    headersObject = headersObject || {};
    if (typeof fetch === "undefined" && !_fetch) {
      throw new Error(
        "Global `fetch` function is not available, pass a fetch polyfill to Genql `createClient`"
      );
    }
    let fetchImpl = _fetch || fetch;
    if (extraFetchOptions?.headers) {
      headersObject = {
        ...headersObject,
        ...extraFetchOptions.headers
      };
      delete extraFetchOptions.headers;
    }
    const res = await fetchImpl(url, {
      headers: {
        "Content-Type": "application/json",
        ...headersObject
      },
      method: "POST",
      body: JSON.stringify(body),
      ...rest,
      ...extraFetchOptions
    });
    if (!res.ok) {
      throw new Error(`${res.statusText}: ${await res.text()}`);
    }
    const json = await res.json();
    return json;
  });
  if (!batch) {
    return async (body, extraFetchOptions) => {
      const json = await fetcher(body, extraFetchOptions);
      if (Array.isArray(json)) {
        return json.map((json2) => {
          if (json2?.errors?.length) {
            throw new GenqlError(json2.errors || [], json2.data);
          }
          return json2.data;
        });
      } else {
        if (json?.errors?.length) {
          throw new GenqlError(json.errors || [], json.data);
        }
        return json.data;
      }
    };
  }
  const batcher = new QueryBatcher(
    async (batchedQuery, extraFetchOptions) => {
      const json = await fetcher(batchedQuery, extraFetchOptions);
      return json;
    },
    batch === true ? DEFAULT_BATCH_OPTIONS : batch
  );
  return async ({ query, variables }) => {
    const json = await batcher.fetch(query, variables);
    if (json?.data) {
      return json.data;
    }
    throw new Error(
      "Genql batch fetcher returned unexpected result " + JSON.stringify(json)
    );
  };
};

// .basehub/runtime/_aliasing.js
var aliasSeparator = "__alias__";
function replaceSystemAliases(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => replaceSystemAliases(item));
  }
  const newObj = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key.includes(aliasSeparator)) {
      const [_prefix, ...rest] = key.split(aliasSeparator);
      const newKey = rest.join(aliasSeparator);
      newObj[newKey] = replaceSystemAliases(value);
    } else {
      newObj[key] = replaceSystemAliases(value);
    }
  }
  return newObj;
}

// .basehub/runtime/_generate-graphql-operation.ts
var parseRequest = (request, ctx, path, options) => {
  if (typeof request === "object" && "__args" in request) {
    const args = request.__args;
    let fields = { ...request };
    delete fields.__args;
    const argNames = Object.keys(args);
    if (argNames.length === 0) {
      return parseRequest(fields, ctx, path, options);
    }
    const field = getFieldFromPath(ctx.root, path);
    const argStrings = argNames.map((argName) => {
      ctx.varCounter++;
      const varName = `v${ctx.varCounter}`;
      const typing = field.args && field.args[argName];
      if (!typing) {
        throw new Error(
          `no typing defined for argument \`${argName}\` in path \`${path.join(
            "."
          )}\``
        );
      }
      const shouldStringifyValue = ["String", "String!"].includes(
        typing[1]
      );
      let value = args[argName];
      if (shouldStringifyValue) {
        if (typeof value === "object") {
          value = JSON.stringify(value);
        }
      }
      ctx.variables[varName] = {
        value,
        typing
      };
      return `${argName}:$${varName}`;
    });
    return `(${argStrings})${parseRequest(fields, ctx, path, options)}`;
  } else if (typeof request === "object" && Object.keys(request).length > 0) {
    const fields = request;
    const fieldNames = Object.keys(fields).filter((k) => Boolean(fields[k]));
    const type = path.length > 0 ? getFieldFromPath(ctx.root, path).type : ctx.root;
    const scalarFields = type.scalar;
    let scalarFieldsFragment;
    const validFieldNames = fieldNames.filter((f) => {
      if (["__scalar", "__name", "__fragmentOn"].includes(f))
        return true;
      if (f.startsWith("on_"))
        return true;
      return type.fields && f in type.fields;
    });
    if (validFieldNames.length === 0) {
      return "";
    }
    if (fieldNames.includes("__scalar")) {
      const falsyFieldNames = new Set(
        Object.keys(fields).filter((k) => !Boolean(fields[k]))
      );
      if (scalarFields?.length) {
        ctx.fragmentCounter++;
        scalarFieldsFragment = `f${ctx.fragmentCounter}`;
        ctx.fragments.push(
          `fragment ${scalarFieldsFragment} on ${type.name}{${scalarFields.filter((f) => !falsyFieldNames.has(f)).map(
            (f) => `${options?.aliasPrefix ? `${options.aliasPrefix}${aliasSeparator}${f}: ` : ""}${f}`
          ).join(",")}}`
        );
      }
    }
    const fieldsSelection = validFieldNames.filter((f) => !["__scalar", "__name", "__fragmentOn"].includes(f)).map((f) => {
      if (f.startsWith("on_")) {
        ctx.fragmentCounter++;
        const implementationFragment = `f${ctx.fragmentCounter}`;
        const parsed = parseRequest(fields[f], ctx, [...path, f], {
          ...options,
          aliasPrefix: implementationFragment
        });
        const typeMatch = f.match(/^on_(.+)/);
        if (!typeMatch || !typeMatch[1])
          throw new Error("match failed");
        ctx.fragments.push(
          `fragment ${implementationFragment} on ${typeMatch[1]}${parsed}`
        );
        return `...${implementationFragment}`;
      } else {
        const field = type.fields?.[f];
        if (!field)
          return "";
        if (!field.type.fields) {
          return `${options?.aliasPrefix ? `${options.aliasPrefix}${aliasSeparator}${f}: ` : ""}${f}`;
        }
        const parsed = parseRequest(
          fields[f],
          ctx,
          [...path, f],
          options
        );
        if (!parsed && field.type.fields) {
          const firstScalar = field.type.scalar?.[0];
          if (firstScalar) {
            return `${options?.aliasPrefix ? `${options.aliasPrefix}${aliasSeparator}${f}: ` : ""}${f}{${firstScalar}}`;
          }
        }
        return `${options?.aliasPrefix ? `${options.aliasPrefix}${aliasSeparator}${f}: ` : ""}${f}${parsed}`;
      }
    }).filter(Boolean).concat(scalarFieldsFragment ? [`...${scalarFieldsFragment}`] : []).join(",");
    return fieldsSelection ? `{${fieldsSelection}}` : "";
  } else {
    return "";
  }
};
var generateGraphqlOperation = (operation, root, fields) => {
  const ctx = {
    root,
    varCounter: 0,
    variables: {},
    fragmentCounter: 0,
    fragments: []
  };
  const result = parseRequest(fields, ctx, []);
  const varNames = Object.keys(ctx.variables);
  const varsString = varNames.length > 0 ? `(${varNames.map((v) => {
    const variableType = ctx.variables[v].typing[1];
    return `$${v}:${variableType}`;
  })})` : "";
  const operationName = fields?.__name || "";
  return {
    query: [
      `${operation} ${operationName}${varsString}${result}`,
      ...ctx.fragments
    ].join(","),
    variables: Object.keys(ctx.variables).reduce(
      (r, v) => {
        r[v] = ctx.variables[v].value;
        return r;
      },
      {}
    ),
    ...operationName ? { operationName: operationName.toString() } : {}
  };
};
var getFieldFromPath = (root, path) => {
  let current;
  if (!root)
    throw new Error("root type is not provided");
  if (path.length === 0)
    throw new Error(`path is empty`);
  path.forEach((f) => {
    const type = current ? current.type : root;
    if (!type.fields)
      throw new Error(`type \`${type.name}\` does not have fields`);
    const possibleTypes = Object.keys(type.fields).filter((i) => i.startsWith("on_")).reduce(
      (types, fieldName) => {
        const field2 = type.fields && type.fields[fieldName];
        if (field2)
          types.push(field2.type);
        return types;
      },
      [type]
    );
    let field = null;
    possibleTypes.forEach((type2) => {
      const found = type2.fields && type2.fields[f];
      if (found)
        field = found;
    });
    if (!field)
      throw new Error(
        `type \`${type.name}\` does not have a field \`${f}\``
      );
    current = field;
  });
  return current;
};

// .basehub/runtime/_create-client.ts
var createClient = ({
  queryRoot,
  mutationRoot,
  subscriptionRoot,
  getExtraFetchOptions,
  ...options
}) => {
  const fetcher = createFetcher(options);
  const client = {};
  if (queryRoot) {
    client.query = async (request) => {
      if (!queryRoot)
        throw new Error("queryRoot argument is missing");
      const body = generateGraphqlOperation("query", queryRoot, request);
      const extraFetchOptions = await getExtraFetchOptions?.(
        "query",
        body,
        request
      );
      return await fetcher(body, extraFetchOptions).then(
        (result) => replaceSystemAliases(result)
      );
    };
  }
  if (mutationRoot) {
    client.mutation = async (request) => {
      if (!mutationRoot)
        throw new Error("mutationRoot argument is missing");
      const body = generateGraphqlOperation(
        "mutation",
        mutationRoot,
        request
      );
      const extraFetchOptions = await getExtraFetchOptions?.(
        "mutation",
        body,
        request
      );
      return await fetcher(
        generateGraphqlOperation("mutation", mutationRoot, request),
        extraFetchOptions
      );
    };
  }
  return client;
};
createClient.replaceSystemAliases = replaceSystemAliases;

// .basehub/runtime/_link-type-map.ts
var linkTypeMap = (typeMap2) => {
  const indexToName = Object.assign(
    {},
    ...Object.keys(typeMap2.types).map((k, i) => ({ [i]: k }))
  );
  let intermediaryTypeMap = Object.assign(
    {},
    ...Object.keys(typeMap2.types || {}).map(
      (k) => {
        const type = typeMap2.types[k];
        const fields = type || {};
        return {
          [k]: {
            name: k,
            // type scalar properties
            scalar: Object.keys(fields).filter((f) => {
              const [type2] = fields[f] || [];
              const isScalar = type2 && typeMap2.scalars.includes(type2);
              if (!isScalar) {
                return false;
              }
              const args = fields[f]?.[1];
              const argTypes = Object.values(args || {}).map((x) => x?.[1]).filter(Boolean);
              const hasRequiredArgs = argTypes.some(
                (str) => str && str.endsWith("!")
              );
              if (hasRequiredArgs) {
                return false;
              }
              return true;
            }),
            // fields with corresponding `type` and `args`
            fields: Object.assign(
              {},
              ...Object.keys(fields).map(
                (f) => {
                  const [typeIndex, args] = fields[f] || [];
                  if (typeIndex == null) {
                    return {};
                  }
                  return {
                    [f]: {
                      // replace index with type name
                      type: indexToName[typeIndex],
                      args: Object.assign(
                        {},
                        ...Object.keys(args || {}).map(
                          (k2) => {
                            if (!args || !args[k2]) {
                              return;
                            }
                            const [
                              argTypeName,
                              argTypeString
                            ] = args[k2];
                            return {
                              [k2]: [
                                indexToName[argTypeName],
                                argTypeString || indexToName[argTypeName]
                              ]
                            };
                          }
                        )
                      )
                    }
                  };
                }
              )
            )
          }
        };
      }
    )
  );
  const res = resolveConcreteTypes(intermediaryTypeMap);
  return res;
};
var resolveConcreteTypes = (linkedTypeMap) => {
  Object.keys(linkedTypeMap).forEach((typeNameFromKey) => {
    const type = linkedTypeMap[typeNameFromKey];
    if (!type.fields) {
      return;
    }
    const fields = type.fields;
    Object.keys(fields).forEach((f) => {
      const field = fields[f];
      if (field.args) {
        const args = field.args;
        Object.keys(args).forEach((key) => {
          const arg = args[key];
          if (arg) {
            const [typeName2] = arg;
            if (typeof typeName2 === "string") {
              if (!linkedTypeMap[typeName2]) {
                linkedTypeMap[typeName2] = { name: typeName2 };
              }
              arg[0] = linkedTypeMap[typeName2];
            }
          }
        });
      }
      const typeName = field.type;
      if (typeof typeName === "string") {
        if (!linkedTypeMap[typeName]) {
          linkedTypeMap[typeName] = { name: typeName };
        }
        field.type = linkedTypeMap[typeName];
      }
    });
  });
  return linkedTypeMap;
};

// .basehub/types.ts
var types_default = {
  "scalars": [
    0,
    1,
    2,
    3,
    16,
    17,
    21,
    22,
    27,
    28,
    29,
    30,
    41,
    46,
    48,
    49
  ],
  "types": {
    "AnalyticsKeyScope": {},
    "BSHBEventSchema": {},
    "BSHBRichTextContentSchema": {},
    "BSHBRichTextTOCSchema": {},
    "BaseRichTextJson": {
      "blocks": [
        41
      ],
      "content": [
        2
      ],
      "toc": [
        3
      ],
      "__typename": [
        41
      ]
    },
    "BlockAudio": {
      "duration": [
        22
      ],
      "fileName": [
        41
      ],
      "fileSize": [
        29
      ],
      "lastModified": [
        22
      ],
      "mimeType": [
        41
      ],
      "url": [
        41
      ],
      "__typename": [
        41
      ]
    },
    "BlockCodeSnippet": {
      "allowedLanguages": [
        17
      ],
      "code": [
        41
      ],
      "html": [
        41,
        {
          "theme": [
            41
          ]
        }
      ],
      "language": [
        17
      ],
      "__typename": [
        41
      ]
    },
    "BlockColor": {
      "b": [
        29
      ],
      "g": [
        29
      ],
      "hex": [
        41
      ],
      "hsl": [
        41
      ],
      "r": [
        29
      ],
      "rgb": [
        41
      ],
      "__typename": [
        41
      ]
    },
    "BlockDocument": {
      "_analyticsKey": [
        41,
        {
          "scope": [
            0
          ]
        }
      ],
      "_dashboardUrl": [
        41
      ],
      "_id": [
        41
      ],
      "_idPath": [
        41
      ],
      "_slug": [
        41
      ],
      "_slugPath": [
        41
      ],
      "_sys": [
        9
      ],
      "_title": [
        41
      ],
      "on_Glosario": [
        24
      ],
      "on_GlosarioItem": [
        25
      ],
      "on_glosarioItem_AsList": [
        51
      ],
      "__typename": [
        41
      ]
    },
    "BlockDocumentSys": {
      "apiNamePath": [
        41
      ],
      "createdAt": [
        41
      ],
      "hash": [
        41
      ],
      "id": [
        28
      ],
      "idPath": [
        41
      ],
      "lastModifiedAt": [
        41
      ],
      "slug": [
        41
      ],
      "slugPath": [
        41
      ],
      "title": [
        41
      ],
      "__typename": [
        41
      ]
    },
    "BlockFile": {
      "fileName": [
        41
      ],
      "fileSize": [
        29
      ],
      "lastModified": [
        22
      ],
      "mimeType": [
        41
      ],
      "url": [
        41
      ],
      "__typename": [
        41
      ]
    },
    "BlockImage": {
      "alt": [
        41
      ],
      "aspectRatio": [
        41
      ],
      "blurDataURL": [
        41
      ],
      "fileName": [
        41
      ],
      "fileSize": [
        29
      ],
      "height": [
        29
      ],
      "lastModified": [
        22
      ],
      "mimeType": [
        41
      ],
      "placeholderURL": [
        41
      ],
      "rawUrl": [
        41
      ],
      "thumbhash": [
        41
      ],
      "url": [
        41,
        {
          "anim": [
            41
          ],
          "background": [
            41
          ],
          "blur": [
            29
          ],
          "border": [
            41
          ],
          "brightness": [
            29
          ],
          "compression": [
            41
          ],
          "contrast": [
            29
          ],
          "dpr": [
            29
          ],
          "fit": [
            41
          ],
          "format": [
            41
          ],
          "gamma": [
            41
          ],
          "gravity": [
            41
          ],
          "height": [
            29
          ],
          "metadata": [
            41
          ],
          "quality": [
            29
          ],
          "rotate": [
            41
          ],
          "sharpen": [
            41
          ],
          "trim": [
            41
          ],
          "width": [
            29
          ]
        }
      ],
      "width": [
        29
      ],
      "__typename": [
        41
      ]
    },
    "BlockList": {
      "_analyticsKey": [
        41,
        {
          "scope": [
            0
          ]
        }
      ],
      "_dashboardUrl": [
        41
      ],
      "_id": [
        41
      ],
      "_idPath": [
        41
      ],
      "_meta": [
        32
      ],
      "_searchKey": [
        41
      ],
      "_slug": [
        41
      ],
      "_slugPath": [
        41
      ],
      "_sys": [
        9
      ],
      "_title": [
        41
      ],
      "on_Glosario": [
        24
      ],
      "on_glosarioItem_AsList": [
        51
      ],
      "__typename": [
        41
      ]
    },
    "BlockOgImage": {
      "height": [
        29
      ],
      "url": [
        41
      ],
      "width": [
        29
      ],
      "__typename": [
        41
      ]
    },
    "BlockRichText": {
      "html": [
        41,
        {
          "slugs": [
            16
          ],
          "toc": [
            16
          ]
        }
      ],
      "json": [
        39
      ],
      "markdown": [
        41
      ],
      "plainText": [
        41
      ],
      "readingTime": [
        29,
        {
          "wpm": [
            29
          ]
        }
      ],
      "on_Content": [
        18
      ],
      "__typename": [
        41
      ]
    },
    "BlockVideo": {
      "aspectRatio": [
        41
      ],
      "duration": [
        22
      ],
      "fileName": [
        41
      ],
      "fileSize": [
        29
      ],
      "height": [
        29
      ],
      "lastModified": [
        22
      ],
      "mimeType": [
        41
      ],
      "url": [
        41
      ],
      "width": [
        29
      ],
      "__typename": [
        41
      ]
    },
    "Boolean": {},
    "CodeSnippetLanguage": {},
    "Content": {
      "html": [
        41,
        {
          "slugs": [
            16
          ],
          "toc": [
            16
          ]
        }
      ],
      "json": [
        19
      ],
      "markdown": [
        41
      ],
      "plainText": [
        41
      ],
      "readingTime": [
        29,
        {
          "wpm": [
            29
          ]
        }
      ],
      "__typename": [
        41
      ]
    },
    "ContentRichText": {
      "content": [
        2
      ],
      "toc": [
        3
      ],
      "__typename": [
        41
      ]
    },
    "DateFilter": {
      "eq": [
        21
      ],
      "isAfter": [
        21
      ],
      "isBefore": [
        21
      ],
      "isNull": [
        16
      ],
      "neq": [
        21
      ],
      "onOrAfter": [
        21
      ],
      "onOrBefore": [
        21
      ],
      "__typename": [
        41
      ]
    },
    "DateTime": {},
    "Float": {},
    "GetUploadSignedURL": {
      "signedURL": [
        41
      ],
      "uploadURL": [
        41
      ],
      "__typename": [
        41
      ]
    },
    "Glosario": {
      "_analyticsKey": [
        41,
        {
          "scope": [
            0
          ]
        }
      ],
      "_dashboardUrl": [
        41
      ],
      "_id": [
        41
      ],
      "_idPath": [
        41
      ],
      "_meta": [
        32
      ],
      "_searchKey": [
        41
      ],
      "_slug": [
        41
      ],
      "_slugPath": [
        41
      ],
      "_sys": [
        9
      ],
      "_title": [
        41
      ],
      "item": [
        25
      ],
      "items": [
        25
      ],
      "__typename": [
        41
      ]
    },
    "GlosarioItem": {
      "_analyticsKey": [
        41,
        {
          "scope": [
            0
          ]
        }
      ],
      "_dashboardUrl": [
        41
      ],
      "_id": [
        41
      ],
      "_idPath": [
        41
      ],
      "_slug": [
        41
      ],
      "_slugPath": [
        41
      ],
      "_sys": [
        9
      ],
      "_title": [
        41
      ],
      "content": [
        18
      ],
      "date": [
        41
      ],
      "icon": [
        41
      ],
      "slug": [
        41
      ],
      "__typename": [
        41
      ]
    },
    "GlosarioItemFilterInput": {
      "AND": [
        26
      ],
      "OR": [
        26
      ],
      "_id": [
        42
      ],
      "_slug": [
        42
      ],
      "_sys_apiNamePath": [
        42
      ],
      "_sys_createdAt": [
        20
      ],
      "_sys_hash": [
        42
      ],
      "_sys_id": [
        42
      ],
      "_sys_idPath": [
        42
      ],
      "_sys_lastModifiedAt": [
        20
      ],
      "_sys_slug": [
        42
      ],
      "_sys_slugPath": [
        42
      ],
      "_sys_title": [
        42
      ],
      "_title": [
        42
      ],
      "date": [
        20
      ],
      "icon": [
        42
      ],
      "slug": [
        42
      ],
      "__typename": [
        41
      ]
    },
    "GlosarioItemOrderByEnum": {},
    "ID": {},
    "Int": {},
    "JSON": {},
    "ListFilter": {
      "isEmpty": [
        16
      ],
      "length": [
        29
      ],
      "__typename": [
        41
      ]
    },
    "ListMeta": {
      "filteredCount": [
        29
      ],
      "totalCount": [
        29
      ],
      "__typename": [
        41
      ]
    },
    "MediaBlock": {
      "fileName": [
        41
      ],
      "fileSize": [
        29
      ],
      "lastModified": [
        22
      ],
      "mimeType": [
        41
      ],
      "url": [
        41
      ],
      "on_BlockAudio": [
        5
      ],
      "on_BlockFile": [
        10
      ],
      "on_BlockImage": [
        11
      ],
      "on_BlockVideo": [
        15
      ],
      "__typename": [
        41
      ]
    },
    "MediaBlockUnion": {
      "on_BlockAudio": [
        5
      ],
      "on_BlockFile": [
        10
      ],
      "on_BlockImage": [
        11
      ],
      "on_BlockVideo": [
        15
      ],
      "on_MediaBlock": [
        33
      ],
      "__typename": [
        41
      ]
    },
    "Mutation": {
      "getUploadSignedURL": [
        23,
        {
          "fileHash": [
            41
          ],
          "fileName": [
            41,
            "String!"
          ]
        }
      ],
      "transaction": [
        45,
        {
          "autoCommit": [
            41
          ],
          "data": [
            41,
            "String!"
          ],
          "skipWorkflows": [
            16
          ],
          "timeout": [
            29
          ]
        }
      ],
      "transactionAsync": [
        41,
        {
          "autoCommit": [
            41
          ],
          "data": [
            41,
            "String!"
          ],
          "skipWorkflows": [
            16
          ]
        }
      ],
      "transactionStatus": [
        45,
        {
          "id": [
            41,
            "String!"
          ]
        }
      ],
      "__typename": [
        41
      ]
    },
    "NumberFilter": {
      "eq": [
        22
      ],
      "gt": [
        22
      ],
      "gte": [
        22
      ],
      "isNull": [
        16
      ],
      "lt": [
        22
      ],
      "lte": [
        22
      ],
      "neq": [
        22
      ],
      "__typename": [
        41
      ]
    },
    "Query": {
      "_componentInstances": [
        50
      ],
      "_structure": [
        30,
        {
          "format": [
            49
          ],
          "resolveTargetsWith": [
            48
          ],
          "targetBlock": [
            44
          ],
          "withConstraints": [
            16
          ],
          "withIDs": [
            16
          ],
          "withTypeOptions": [
            16
          ]
        }
      ],
      "_sys": [
        38
      ],
      "glosario": [
        24,
        {
          "filter": [
            26
          ],
          "first": [
            29
          ],
          "orderBy": [
            27
          ],
          "skip": [
            29
          ]
        }
      ],
      "__typename": [
        41
      ]
    },
    "RepoSys": {
      "dashboardUrl": [
        41
      ],
      "forkUrl": [
        41
      ],
      "hash": [
        41
      ],
      "id": [
        28
      ],
      "slug": [
        41
      ],
      "title": [
        41
      ],
      "__typename": [
        41
      ]
    },
    "RichTextJson": {
      "content": [
        2
      ],
      "toc": [
        3
      ],
      "on_BaseRichTextJson": [
        4
      ],
      "on_ContentRichText": [
        19
      ],
      "__typename": [
        41
      ]
    },
    "SelectFilter": {
      "excludes": [
        41
      ],
      "excludesAll": [
        41
      ],
      "includes": [
        41
      ],
      "includesAll": [
        41
      ],
      "includesAny": [
        41
      ],
      "isEmpty": [
        16
      ],
      "__typename": [
        41
      ]
    },
    "String": {},
    "StringFilter": {
      "contains": [
        41
      ],
      "endsWith": [
        41
      ],
      "eq": [
        41
      ],
      "isNull": [
        16
      ],
      "matches": [
        43
      ],
      "notEq": [
        41
      ],
      "startsWith": [
        41
      ],
      "__typename": [
        41
      ]
    },
    "StringMatchesFilter": {
      "caseSensitive": [
        16
      ],
      "pattern": [
        41
      ],
      "__typename": [
        41
      ]
    },
    "TargetBlock": {
      "focus": [
        16
      ],
      "id": [
        41
      ],
      "label": [
        41
      ],
      "__typename": [
        41
      ]
    },
    "TransactionStatus": {
      "duration": [
        29
      ],
      "endedAt": [
        41
      ],
      "id": [
        41
      ],
      "message": [
        41
      ],
      "startedAt": [
        41
      ],
      "status": [
        46
      ],
      "__typename": [
        41
      ]
    },
    "TransactionStatusEnum": {},
    "Variant": {
      "apiName": [
        41
      ],
      "color": [
        41
      ],
      "id": [
        41
      ],
      "isDefault": [
        16
      ],
      "label": [
        41
      ],
      "__typename": [
        41
      ]
    },
    "_ResolveTargetsWithEnum": {},
    "_StructureFormatEnum": {},
    "_components": {
      "glosarioItem": [
        51,
        {
          "filter": [
            26
          ],
          "first": [
            29
          ],
          "orderBy": [
            27
          ],
          "skip": [
            29
          ]
        }
      ],
      "__typename": [
        41
      ]
    },
    "glosarioItem_AsList": {
      "_analyticsKey": [
        41,
        {
          "scope": [
            0
          ]
        }
      ],
      "_dashboardUrl": [
        41
      ],
      "_id": [
        41
      ],
      "_idPath": [
        41
      ],
      "_meta": [
        32
      ],
      "_searchKey": [
        41
      ],
      "_slug": [
        41
      ],
      "_slugPath": [
        41
      ],
      "_sys": [
        9
      ],
      "_title": [
        41
      ],
      "item": [
        25
      ],
      "items": [
        25
      ],
      "__typename": [
        41
      ]
    }
  }
};

// .basehub/schema.ts
function fragmentOn(name, fields) {
  return { __fragmentOn: name, ...fields };
}
function fragmentOnRecursiveCollection(name, fields, options) {
  let current = {
    ...fields
  };
  if (options.levels > 0) {
    current[options.recursiveKey] = {
      ...options.getLevelArgs ? { __args: options.getLevelArgs(options.levels) } : {},
      items: fragmentOnRecursiveCollection(name, fields, {
        ...options,
        levels: options.levels - 1
      })
    };
  }
  return current;
}

// .basehub/index.ts
var typeMap = linkTypeMap(types_default);
var createClient2 = function(options) {
  const { url, headers } = getStuffFromEnv(options);
  return createClient({
    url: url.toString(),
    ...options,
    headers: { ...options?.headers, ...headers },
    queryRoot: typeMap.Query,
    mutationRoot: typeMap.Mutation,
    subscriptionRoot: typeMap.Subscription
  });
};
var everything = {
  __scalar: true
};
var generateQueryOp = function(fields) {
  return generateGraphqlOperation("query", typeMap.Query, fields);
};
var generateMutationOp = function(fields) {
  return generateGraphqlOperation("mutation", typeMap.Mutation, fields);
};
var getStuffFromEnv = (options) => {
  const defaultEnvVarPrefix = "BASEHUB";
  options = options || {};
  if (options.token === void 0) {
    options.token = null;
  }
  if (options.prefix === void 0) {
    options.prefix = null;
  }
  if (!options.draft && false) {
    options.draft = true;
  }
  const buildEnvVarName = (name) => {
    let prefix = defaultEnvVarPrefix;
    if (options.prefix) {
      if (options.prefix.endsWith("_")) {
        options.prefix = options.prefix.slice(0, -1);
      }
      if (options.prefix.endsWith(name)) {
        options.prefix = options.prefix.slice(0, -name.length);
      }
      if (options.prefix.endsWith(defaultEnvVarPrefix)) {
        prefix = options.prefix;
      } else {
        prefix = `${options.prefix}_${defaultEnvVarPrefix}`;
      }
    }
    return `${prefix}_${name}`;
  };
  const getEnvVar = (name) => process.env[buildEnvVarName(name)];
  const parsedDebugForcedURL = getEnvVar("DEBUG_FORCED_URL");
  const parsedBackwardsCompatURL = getEnvVar("URL");
  const backwardsCompatURL = parsedBackwardsCompatURL ? new URL(parsedBackwardsCompatURL) : void 0;
  const basehubUrl = new URL(
    parsedDebugForcedURL ? parsedDebugForcedURL : `https://api.basehub.com/graphql`
  );
  const parsedBasehubTokenEnv = getEnvVar("TOKEN");
  const parsedBasehubRefEnv = getEnvVar("REF");
  const parsedBasehubDraftEnv = getEnvVar("DRAFT");
  const parsedBasehubApiVersionEnv = getEnvVar("API_VERSION");
  let tokenNotFoundErrorMessage = `\u{1F534} Token not found. Make sure to include the ${buildEnvVarName(
    "TOKEN"
  )} env var.`;
  const resolveTokenParam = (token2) => {
    if (!token2)
      return null;
    const isRaw = token2.startsWith("bshb_");
    if (isRaw)
      return token2;
    tokenNotFoundErrorMessage = `\u{1F534} Token not found. Make sure to include the ${token2} env var.`;
    return process.env[token2] ?? "";
  };
  const resolvedToken = resolveTokenParam(options?.token ?? null);
  const token = resolvedToken ?? basehubUrl.searchParams.get("token") ?? parsedBasehubTokenEnv ?? (backwardsCompatURL ? backwardsCompatURL.searchParams.get("token") : void 0) ?? null;
  if (!token) {
    throw new Error(tokenNotFoundErrorMessage);
  }
  let draft = basehubUrl.searchParams.get("draft") ?? parsedBasehubDraftEnv ?? (backwardsCompatURL ? backwardsCompatURL.searchParams.get("draft") : void 0) ?? false;
  if (options?.draft !== void 0) {
    draft = options.draft;
  }
  let apiVersion = basehubUrl.searchParams.get("api-version") ?? parsedBasehubApiVersionEnv ?? (backwardsCompatURL ? backwardsCompatURL.searchParams.get("api-version") : void 0) ?? "4";
  if (options?.apiVersion !== void 0) {
    apiVersion = options.apiVersion;
  }
  if (basehubUrl.pathname.split("/")[1] !== "graphql") {
    throw new Error(`\u{1F534} Invalid URL. The URL needs to point your repo's GraphQL endpoint, so the pathname should end with /graphql.`);
  }
  basehubUrl.searchParams.delete("token");
  basehubUrl.searchParams.delete("ref");
  basehubUrl.searchParams.delete("draft");
  basehubUrl.searchParams.delete("api-version");
  const gitBranch = "main";
  const gitCommitSHA = "4af1313da5a98c8fe86e3b85d6655f8c6248d191";
  const sdkBuildId2 = "bshb_sdk_e3734412da928";
  return {
    isForcedDraft: false,
    draft,
    url: basehubUrl,
    sdkBuildId: sdkBuildId2,
    headers: {
      "x-basehub-token": token,
      "x-basehub-ref": options?.ref ?? resolvedRef.ref,
      "x-basehub-sdk-build-id": sdkBuildId2,
      ...gitBranch ? { "x-basehub-git-branch": gitBranch } : {},
      ...gitCommitSHA ? { "x-basehub-git-commit-sha": gitCommitSHA } : {},
      ...gitBranchDeploymentURL ? { "x-basehub-git-branch-deployment-url": gitBranchDeploymentURL } : {},
      ...productionDeploymentURL ? { "x-basehub-production-deployment-url": productionDeploymentURL } : {},
      ...draft ? { "x-basehub-draft": "true" } : {},
      ...apiVersion ? { "x-basehub-api-version": apiVersion } : {}
    }
  };
};
var sdkBuildId = "bshb_sdk_e3734412da928";
var resolvedRef = { "repoHash": "e0df059f", "type": "branch", "ref": "main", "createSuggestedBranchLink": null, "id": "msspTcJpMPfOPTg5O00aI", "name": "main", "createdAt": "2025-05-13T12:09:33.554Z", "headCommitId": "EDwzkvycXzOGW5iYpXb4U", "isDefault": true, "workingRootBlockId": "JVT4YiXCVEhme6C6JrdHy" };
var gitBranchDeploymentURL = null;
var productionDeploymentURL = null;
var isNextjs = true;
function hashObject(obj) {
  const sortObjectKeys = (obj2) => {
    if (!isObjectAsWeCommonlyCallIt(obj2))
      return obj2;
    return Object.keys(obj2).sort().reduce((acc, key) => {
      acc[key] = obj2[key];
      return acc;
    }, {});
  };
  const recursiveSortObjectKeys = (obj2) => {
    const sortedObj2 = sortObjectKeys(obj2);
    if (!isObjectAsWeCommonlyCallIt(sortedObj2))
      return sortedObj2;
    Object.keys(sortedObj2).forEach((key) => {
      if (isObjectAsWeCommonlyCallIt(sortedObj2[key])) {
        sortedObj2[key] = recursiveSortObjectKeys(
          sortedObj2[key]
        );
      } else if (Array.isArray(sortedObj2[key])) {
        sortedObj2[key] = sortedObj2[key].map(
          (item) => {
            if (isObjectAsWeCommonlyCallIt(item)) {
              return recursiveSortObjectKeys(item);
            } else {
              return item;
            }
          }
        );
      }
    });
    return sortedObj2;
  };
  const isObjectAsWeCommonlyCallIt = (obj2) => {
    return Object.prototype.toString.call(obj2) === "[object Object]";
  };
  const sortedObj = recursiveSortObjectKeys(obj);
  const str = JSON.stringify(sortedObj);
  let hash = 0;
  for (let i = 0, len = str.length; i < len; i++) {
    let chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return Math.abs(hash).toString();
}
function cacheTagFromQuery(query, apiVersion) {
  const now = performance.now();
  const result = "basehub-" + hashObject({ ...query, refId: resolvedRef.id, ...apiVersion ? { apiVersion } : {} });
  return result;
}
var basehub = (options) => {
  const { url, headers } = getStuffFromEnv(options);
  if (!options) {
    options = {};
  }
  options.getExtraFetchOptions = async (op, _body, originalRequest) => {
    if (op !== "query")
      return {};
    let extra = {
      headers: {
        "x-basehub-sdk-build-id": sdkBuildId
      }
    };
    let isNextjsDraftMode = false;
    if (options.draft === void 0) {
      try {
        const { draftMode } = await import("next/headers");
        isNextjsDraftMode = (await draftMode()).isEnabled;
      } catch (error) {
      }
    }
    const isDraftResolved = isNextjsDraftMode || options.draft === true;
    if (isDraftResolved) {
      extra.headers = { ...extra.headers, "x-basehub-draft": "true" };
      extra.next = { revalidate: void 0 };
      extra.cache = "no-store";
      try {
        const { cookies } = await import("next/headers");
        const cookieStore = await cookies();
        const ref = cookieStore.get("bshb-preview-ref-" + resolvedRef.repoHash)?.value;
        if (ref) {
          extra.headers = {
            ...extra.headers,
            "x-basehub-ref": ref
          };
        }
      } catch (error) {
      }
    }
    if (isDraftResolved)
      return extra;
    if (typeof options?.next === "undefined") {
      let isNextjs2 = false;
      try {
        isNextjs2 = !!await import("next/headers");
      } catch (error) {
      }
      if (isNextjs2) {
        const cacheTag = cacheTagFromQuery(originalRequest, headers["x-basehub-api-version"]);
        extra.next = { tags: [cacheTag] };
        extra.headers = {
          ...extra.headers,
          "x-basehub-cache-tag": cacheTag
        };
      }
    }
    return extra;
  };
  return {
    ...createClient2(options),
    raw: createFetcher({ ...options, url, headers })
  };
};
basehub.replaceSystemAliases = createClient.replaceSystemAliases;
export {
  GenqlError,
  basehub,
  cacheTagFromQuery,
  everything,
  fragmentOn,
  fragmentOnRecursiveCollection,
  generateMutationOp,
  generateQueryOp,
  getStuffFromEnv,
  gitBranchDeploymentURL,
  isNextjs,
  productionDeploymentURL,
  resolvedRef,
  sdkBuildId
};
